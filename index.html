<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Idle Virus — Digital Plague</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#0b0f17;--card:#0f1720;--accent:#00ff9c;--muted:#98a0b3;--danger:#ff5c7a;--glow:0 0 12px rgba(0,255,156,0.6),0 0 24px rgba(0,255,156,0.3)}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:#e6eef8;}
    body{display:flex;align-items:center;justify-content:center;overflow:hidden}
    .app{width:900px;max-width:98%;height:90vh;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:18px;box-shadow:0 10px 40px rgba(2,6,23,0.7);overflow:hidden;position:relative}

    /* Splash */
    .splash{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background:radial-gradient(circle at center, rgba(0,255,156,0.12), transparent 70%),rgba(3,6,10,0.8);backdrop-filter:blur(6px);z-index:30;animation:fadeIn 1s ease}
    @keyframes fadeIn{from{opacity:0}to{opacity:1}}
    .logo{font-weight:800;font-size:36px;display:flex;align-items:center;gap:14px;text-shadow:var(--glow)}
    .logo .symbol{width:90px;height:90px;border-radius:16px;display:grid;place-items:center;background:linear-gradient(135deg,var(--accent),#00e0d0);color:#02111a;font-weight:900;font-size:28px;box-shadow:var(--glow)}
    .splash p{color:var(--muted);max-width:70%;text-align:center;margin:14px 0 28px}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:10px 18px;border-radius:10px;color:var(--accent);cursor:pointer;font-weight:700;transition:all .2s}
    .btn:hover{background:rgba(0,255,156,0.06);box-shadow:var(--glow)}
    .btn.secondary{border-color:rgba(255,255,255,0.03);color:var(--muted);background:rgba(255,255,255,0.01)}
    .btn.danger.is-confirming { background: var(--danger); border-color: transparent; color: #fff; text-shadow: 0 0 8px rgba(255, 255, 255, 0.5); }


    .main{display:flex;height:100%}
    aside{width:280px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));padding:16px;box-sizing:border-box;overflow-y:auto}
    main{flex:1;padding:16px;box-sizing:border-box;overflow-y:auto;display:flex;flex-direction:column;gap:12px}

    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent);padding:12px;border-radius:12px;margin-top:12px;box-shadow:0 2px 8px rgba(0,0,0,0.2)}
    .panel:first-child{margin-top:0}
    .stat-row{display:flex;justify-content:space-between;align-items:center}
    .big-counter{font-size:28px;font-weight:800;color:var(--accent);text-shadow:var(--glow)}
    .infect-btn{height:100px;border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(circle at center, rgba(0,255,156,0.15), rgba(0,255,156,0.04));border:2px solid rgba(0,255,152,0.1);cursor:pointer;transition:all .15s;box-shadow:var(--glow)}
    .infect-btn:hover{transform:scale(1.05)}
    .upgrade{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;margin-top:6px;background:rgba(255,255,255,0.02);transition:all .15s;font-size:13px}
    .upgrade:hover{background:rgba(0,255,156,0.05)}
    .upgrade button{padding:6px 10px;border-radius:6px;border:none;background:var(--accent);color:#02111a;font-weight:700;cursor:pointer;transition:all .2s;font-size:11px}
    .upgrade button:hover{box-shadow:var(--glow)}
    .upgrade button:disabled{background:rgba(255,255,255,0.1);color:var(--muted);cursor:not-allowed;box-shadow:none}
    .cost{color:var(--muted);font-size:11px}
    #mapCanvas{width:100%;height:200px;background:#02060d;border-radius:12px;display:block;margin-top:8px;}
    #logBox{margin-top:8px;max-height:80px;overflow-y:auto;font-size:11px;color:var(--muted);}
    .bar-bg{width:100%;height:8px;background:rgba(255,255,255,0.1);border-radius:4px;overflow:hidden;margin-top:4px}
    .bar-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--danger));border-radius:4px;transition:width 0.3s;width:0%}
    .meta{font-size:12px;color:var(--muted);margin-top:8px}
    .hidden{display:none}
    .upgrade-title{font-weight:600;color:var(--accent);font-size:12px}
    .upgrade-desc{font-size:10px;color:var(--muted);margin-top:2px}
    .upgrades-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
    .upgrade.grid{margin-top:0;flex-direction:column;align-items:flex-start;padding:10px}
    .upgrade.grid .upgrade-info{width:100%;margin-bottom:8px}
    .upgrade.grid button{width:100%}
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="splash" id="splash">
      <div class="logo">
        <div class="symbol">IV</div>
        <div><div style="font-size:20px">Idle Virus</div><div style="font-size:12px;color:var(--muted)">Digital Plague — v2</div></div>
      </div>
      <p>Spread your code across devices. Unlock real virus-inspired upgrades. Recompile for permanent improvements when threat levels get too high.</p>
      <div style="display:flex;gap:10px">
        <button class="btn" id="startBtn">Start New Infection</button>
        <button class="btn secondary danger" id="wipeBtn">Wipe Save</button>
      </div>
      <div class="meta" style="margin-top:10px">Tip: Recompiling is key to long-term growth.</div>
    </div>

    <div class="main hidden" id="gameMain">
      <aside>
        <div class="panel">
          <div class="stat-row"><div>IP: <span id="ipCount">0</span></div><div>IP/sec: <span id="ipPerSec">0</span></div></div>
          <div style="margin-top:8px">Threat: <div class="bar-bg"><div class="bar-fill" id="threatFill"></div></div></div>
          <div class="meta" id="antivirusState">Antivirus: Idle</div>
          <div class="meta">Code Fragments: <span id="fragmentCount">0</span> (+<span id="prestigeBonus">0.0</span>% boost)</div>
        </div>

        <div class="panel" id="recompilePanel">
            <div class="meta">Recompile Core</div>
            <div class="upgrade-desc" style="font-size:11px; margin-top:4px;">When threat is critical (>90%), recompile your virus. This resets progress but grants Code Fragments, permanently boosting IP gain.</div>
            <div class="meta">Fragments on reset: <span id="fragmentsOnReset">0</span></div>
            <button id="recompileBtn" class="btn" style="width:100%; margin-top:8px;" disabled>Recompile Virus</button>
        </div>

        <div class="panel">
          <div class="meta">Upgrades</div>
          <div id="upgradesUI"></div>
        </div>

        <div class="panel">
          <canvas id="mapCanvas"></canvas>
          <div class="meta">Infected Network Map</div>
        </div>

        <div id="logBox"></div>
      </aside>

      <main>
        <div class="infect-btn" id="infectBtn"><h2>Inject</h2><p id="infectHint">+1 IP per click</p></div>
        
        <div class="panel">
          <div class="meta">Advanced Upgrades</div>
          <div id="advancedUpgradesUI"></div>
        </div>
      </main>
    </div>
  </div>

  <script>
    /* ======= CONSTANTS & CONFIG ======= */
    const CONSTANTS = {
        UPGRADE_COST_SCALING: 1.15,
        ADVANCED_UPGRADE_COST_SCALING: 1.25,
        THREAT_PER_CLICK: 0.5,
        BASE_THREAT_DECAY_PER_SEC: 1.5,
        PRESTIGE_BONUS_PER_FRAGMENT: 0.05, // 5% boost per fragment
        AUTOSAVE_INTERVAL: 10000, // in ms
    };

    /* ======= STATE ======= */
    const getInitialState = () => ({
      ip: 0,
      ipPerSec: 0,
      ipPerClick: 1,
      threat: 0,
      fragments: 0,
      upgrades: {},
      autoInfectRate: 0,
      threatDecayMultiplier: 1,
      fragmentGainMultiplier: 1,
      lastTick: Date.now(),
      infectedNodes: []
    });

    let state = getInitialState();

    /* ======= UPGRADES ======= */
    const ALL_UPGRADES = {
        'morris': {type:'basic', title:'Morris Worm',desc:'First worm: +0.5 IP/sec',cost:50,effect:s=>s.ipPerSec+=0.5,lore:'The first worm, unleashed from MIT, proved the net could be crippled.'},
        'iloveyou': {type:'basic', title:'ILOVEYOU',desc:'Social engineering: +5% click spread',cost:200,effect:s=>s.autoInfectRate+=0.05,lore:'A love letter that broke millions of hearts.'},
        'conficker': {type:'basic', title:'Conficker',desc:'+5 IP/sec from botnets',cost:500,effect:s=>s.ipPerSec+=5,lore:'Conficker turned countless machines into a silent army.'},
        'stuxnet': {type:'basic', title:'Stuxnet',desc:'Doubles effect of Code Fragments',cost:2500,effect:s=>{/* Handled via prestige multiplier calc */},lore:'A worm that sabotaged centrifuges in the real world.'},
        'wannacry': {type:'advanced', title:'WannaCry',desc:'+3 IP/click, spreads to 3 devices',cost:10000,effect:s=>{s.ipPerClick+=3;s.autoInfectRate+=0.1},lore:'Ransomware that spread like wildfire across hospitals.'},
        'emotet': {type:'advanced', title:'Emotet',desc:'+15% IP/sec scaling',cost:25000,effect:s=>s.ipPerSec*=1.15,lore:'A resilient parasite that re-infected networks repeatedly.'},
        'mirai': {type:'advanced', title:'Mirai Botnet',desc:'IoT infection: +50 IP/sec',cost:75000,effect:s=>s.ipPerSec+=50,lore:'Hijacked cameras and routers into a massive DDoS army.'},
        'notpetya': {type:'advanced', title:'NotPetya',desc:'Destructive wiper: ×3 threat decay',cost:150000,effect:s=>s.threatDecayMultiplier=3,lore:'A cyber-weapon disguised as ransomware.'},
        'ryuk': {type:'advanced', title:'Ryuk',desc:'Targeted ransomware: +100% Fragment gain',cost:500000,effect:s=>s.fragmentGainMultiplier+=1,lore:'Precision strikes against high-value targets.'},
        'solarwinds': {type:'advanced', title:'SolarWinds',desc:'Supply chain: +1 base IP/sec per upgrade owned',cost:2000000,effect:s=>{/* Handled in passive gain calc */},lore:'The most sophisticated supply chain attack in history.'}
    };

    /* ======= DOM ======= */
    const $ = id => document.getElementById(id);
    const ipCount = $('ipCount'), ipPerSec = $('ipPerSec'), infectBtn = $('infectBtn');
    const infectHint = $('infectHint'), upgradesUI = $('upgradesUI'), mapCanvas = $('mapCanvas');
    const logBox = $('logBox'), startBtn = $('startBtn'), wipeBtn = $('wipeBtn');
    const splash = $('splash'), gameMain = $('gameMain'), threatFill = $('threatFill');
    const antivirusState = $('antivirusState'), fragmentCount = $('fragmentCount');
    const advancedUpgradesUI = $('advancedUpgradesUI'), recompileBtn = $('recompileBtn');
    const prestigeBonus = $('prestigeBonus'), fragmentsOnReset = $('fragmentsOnReset');
    const ctx = mapCanvas.getContext('2d');

    /* ======= GAME LOGIC ======= */
    function formatNumber(num) {
      if (num < 1000) return num.toFixed(0);
      const suffixes = ['', 'k', 'M', 'B', 'T', 'Qa', 'Qi'];
      const i = Math.floor(Math.log10(num) / 3);
      if (i >= suffixes.length) return num.toExponential(2);
      return (num / Math.pow(1000, i)).toFixed(2) + suffixes[i];
    }

    function addLog(message) {
      const div = document.createElement('div');
      div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logBox.insertBefore(div, logBox.firstChild);
      if (logBox.children.length > 20) logBox.removeChild(logBox.lastChild);
    }
    
    function calculatePrestigeMultiplier() {
        let stuxnetMultiplier = state.upgrades.stuxnet ? 2 : 1;
        return 1 + (state.fragments * CONSTANTS.PRESTIGE_BONUS_PER_FRAGMENT * stuxnetMultiplier);
    }

    function calculatePassiveIPS() {
        let solarwindsBonus = 0;
        if(state.upgrades.solarwinds){
            solarwindsBonus = Object.keys(state.upgrades).length;
        }
        return (state.ipPerSec + solarwindsBonus) * calculatePrestigeMultiplier();
    }
    
    function calculateClickIPS() {
        return state.ipPerClick * calculatePrestigeMultiplier();
    }

    function updateUI() {
        const passiveIPS = calculatePassiveIPS();
        const clickIPS = calculateClickIPS();

        ipCount.textContent = formatNumber(state.ip);
        ipPerSec.textContent = formatNumber(passiveIPS);
        infectHint.textContent = `+${formatNumber(clickIPS)} IP per click`;
        fragmentCount.textContent = formatNumber(state.fragments);
        prestigeBonus.textContent = ((calculatePrestigeMultiplier() - 1) * 100).toFixed(1);

        const threatPercent = Math.min(state.threat / 100, 1) * 100;
        threatFill.style.width = threatPercent + '%';

        if (state.threat > 80) {
            antivirusState.textContent = 'Antivirus: ALERT';
            antivirusState.style.color = 'var(--danger)';
        } else if (state.threat > 50) {
            antivirusState.textContent = 'Antivirus: Scanning';
            antivirusState.style.color = 'var(--accent)';
        } else {
            antivirusState.textContent = 'Antivirus: Idle';
            antivirusState.style.color = 'var(--muted)';
        }

        // Recompile section update
        const canRecompile = state.threat > 90;
        recompileBtn.disabled = !canRecompile;
        const fragmentsToGain = canRecompile ? Math.floor(Math.sqrt(state.ip / 10000) * state.fragmentGainMultiplier) : 0;
        fragmentsOnReset.textContent = formatNumber(fragmentsToGain);
        
        // Update upgrade buttons (more efficient than rebuilding)
        updateUpgradeButtons();
    }
    
    function initUpgrades() {
        upgradesUI.innerHTML = '';
        advancedUpgradesUI.innerHTML = '<div class="upgrades-grid"></div>';
        const grid = advancedUpgradesUI.querySelector('.upgrades-grid');

        for (const id in ALL_UPGRADES) {
            const upgrade = ALL_UPGRADES[id];
            const div = document.createElement('div');
            
            if (upgrade.type === 'basic') {
                div.className = 'upgrade';
                div.innerHTML = `
                  <div>
                    <div class="upgrade-title">${upgrade.title} <span data-owned="${id}"></span></div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                    <div class="cost" data-cost="${id}">Cost: ${formatNumber(upgrade.cost)} IP</div>
                  </div>
                  <button data-upgrade="${id}">Buy</button>
                `;
                upgradesUI.appendChild(div);
            } else { // advanced
                div.className = 'upgrade grid';
                div.innerHTML = `
                  <div class="upgrade-info">
                    <div class="upgrade-title">${upgrade.title} <span data-owned="${id}"></span></div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                    <div class="cost" data-cost="${id}">Cost: ${formatNumber(upgrade.cost)} IP</div>
                  </div>
                  <button data-upgrade="${id}">Buy</button>
                `;
                grid.appendChild(div);
            }
        }
    }
    
    function updateUpgradeButtons() {
        for (const id in ALL_UPGRADES) {
            const upgrade = ALL_UPGRADES[id];
            const owned = state.upgrades[id] || 0;
            const costMultiplier = upgrade.type === 'advanced' ? CONSTANTS.ADVANCED_UPGRADE_COST_SCALING : CONSTANTS.UPGRADE_COST_SCALING;
            const currentCost = Math.floor(upgrade.cost * Math.pow(costMultiplier, owned));
            
            const btn = document.querySelector(`button[data-upgrade="${id}"]`);
            const costEl = document.querySelector(`div[data-cost="${id}"]`);
            const ownedEl = document.querySelector(`span[data-owned="${id}"]`);

            if (btn && costEl && ownedEl) {
                btn.disabled = state.ip < currentCost;
                costEl.textContent = `Cost: ${formatNumber(currentCost)} IP`;
                ownedEl.textContent = owned > 0 ? `(Lv ${owned})` : '';
            }
        }
    }

    function buyUpgrade(id) {
        const upgrade = ALL_UPGRADES[id];
        if (!upgrade) return;

        const owned = state.upgrades[id] || 0;
        const costMultiplier = upgrade.type === 'advanced' ? CONSTANTS.ADVANCED_UPGRADE_COST_SCALING : CONSTANTS.UPGRADE_COST_SCALING;
        const cost = Math.floor(upgrade.cost * Math.pow(costMultiplier, owned));

        if (state.ip >= cost) {
            state.ip -= cost;
            state.upgrades[id] = owned + 1;
            upgrade.effect(state);
            addLog(`Deployed ${upgrade.title}! ${upgrade.lore}`);
            updateUI(); // Full UI refresh after state change
            saveGame();
        }
    }

    function infectClick() {
        const gain = calculateClickIPS();
        state.ip += gain;
        state.threat += CONSTANTS.THREAT_PER_CLICK;

        if (Math.random() < state.autoInfectRate) {
            const bonus = Math.floor(gain * 2);
            state.ip += bonus;
            addLog(`Lateral movement! +${formatNumber(bonus)} bonus IP`);
        }

        if (Math.random() < 0.3) addInfectedNode();
        updateUI();
    }
    
    function recompileVirus() {
        const canRecompile = state.threat > 90;
        if (!canRecompile) return;
        
        const fragmentsGained = Math.floor(Math.sqrt(state.ip / 10000) * state.fragmentGainMultiplier);
        if (fragmentsGained <= 0) {
             addLog("Recompile aborted: Not enough progress to gain fragments.");
             return;
        }

        const oldFragments = state.fragments;
        const newState = getInitialState();
        newState.fragments = oldFragments + fragmentsGained;
        
        state = newState;
        
        addLog(`RECOMPILE COMPLETE. Gained ${formatNumber(fragmentsGained)} fragments. Virus rebooted stronger.`);
        saveGame();
        updateUI();
    }

    function addInfectedNode() {
        if (state.infectedNodes.length >= 50) return;
        if (!mapCanvas.width) return;

        const node = {
            x: Math.random() * (mapCanvas.width - 20) + 10,
            y: Math.random() * (mapCanvas.height - 20) + 10,
            age: 0,
            type: Math.random() < 0.7 ? 'pc' : Math.random() < 0.5 ? 'server' : 'mobile'
        };
        state.infectedNodes.push(node);
    }

    function renderMap() {
        if (!mapCanvas.width || mapCanvas.offsetWidth === 0) return;
        
        ctx.fillStyle = '#02060d';
        ctx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

        ctx.strokeStyle = 'rgba(0, 255, 156, 0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i < state.infectedNodes.length; i++) {
            for (let j = i + 1; j < state.infectedNodes.length; j++) {
                const from = state.infectedNodes[i];
                const to = state.infectedNodes[j];
                const dist = Math.hypot(from.x - to.x, from.y - to.y);
                if (dist < 100) { // Only draw lines between close nodes
                    ctx.globalAlpha = 1 - (dist / 100);
                    ctx.beginPath();
                    ctx.moveTo(from.x, from.y);
                    ctx.lineTo(to.x, to.y);
                    ctx.stroke();
                }
            }
        }
        ctx.globalAlpha = 1.0;
        
        state.infectedNodes.forEach(node => {
            const alpha = Math.max(0.3, 1 - node.age / 1000);
            if (node.type === 'server') {
                ctx.fillStyle = `rgba(255, 92, 122, ${alpha})`;
                ctx.fillRect(node.x - 3, node.y - 3, 6, 6);
            } else {
                ctx.fillStyle = `rgba(0, 255, 156, ${alpha})`;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            node.age++;
        });
        state.infectedNodes = state.infectedNodes.filter(node => node.age < 1000);
    }

    function gameLoop() {
        const now = Date.now();
        const deltaTime = (now - state.lastTick) / 1000;
        state.lastTick = now;

        state.ip += calculatePassiveIPS() * deltaTime;
        state.threat = Math.max(0, state.threat - deltaTime * CONSTANTS.BASE_THREAT_DECAY_PER_SEC * state.threatDecayMultiplier);
        
        updateUI();
        renderMap();
        requestAnimationFrame(gameLoop);
    }

    function saveGame() {
        localStorage.setItem('idleVirusSave_v2', JSON.stringify(state));
    }

    function loadGame() {
        const save = localStorage.getItem('idleVirusSave_v2');
        if (save) {
            const savedState = JSON.parse(save);
            // Deep merge to handle new properties in future updates
            Object.assign(state, savedState);
            state.lastTick = Date.now();
            addLog('Save file found. Resuming infection...');
        } else {
            addLog('No save file found. Initializing new digital plague...');
        }
    }

    function resetGame() {
        localStorage.removeItem('idleVirusSave_v2');
        state = getInitialState();
        saveGame();
        location.reload();
    }

    /* ======= EVENT LISTENERS ======= */
    startBtn.addEventListener('click', () => {
        loadGame();
        splash.style.display = 'none'; // More performant than adding/removing class
        gameMain.classList.remove('hidden');
        
        initUpgrades(); // Build the upgrade UI once
        
        setTimeout(() => {
            mapCanvas.width = mapCanvas.offsetWidth;
            mapCanvas.height = mapCanvas.offsetHeight;
        }, 100);
        
        gameLoop();
    });

    let wipeConfirmTimeout;
    wipeBtn.addEventListener('click', () => {
        if (wipeBtn.classList.contains('is-confirming')) {
            clearTimeout(wipeConfirmTimeout);
            addLog('Save file wiped. System memory erased.');
            resetGame();
        } else {
            wipeBtn.textContent = 'Confirm Wipe?';
            wipeBtn.classList.add('is-confirming');
            wipeConfirmTimeout = setTimeout(() => {
                wipeBtn.textContent = 'Wipe Save';
                wipeBtn.classList.remove('is-confirming');
            }, 3000);
        }
    });

    infectBtn.addEventListener('click', infectClick);
    recompileBtn.addEventListener('click', recompileVirus);
    
    // Event delegation for all upgrade buttons
    document.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON' && e.target.dataset.upgrade) {
            buyUpgrade(e.target.dataset.upgrade);
        }
    });

    setInterval(saveGame, CONSTANTS.AUTOSAVE_INTERVAL);
  </script>
</body>
</html>

